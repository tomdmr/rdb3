#!/usr/bin/python3
##################
# Clean new implementation from scratch after 
# Win10 machine crashed. Yes I know.

import argparse
from configparser import ConfigParser
import shlex
import subprocess
import sys
import getpass
from os import environ, path, access, W_OK
import getopt
import logging
import logging.config
import re
import socket

def tweetAlert( cmd, message):
    """
        Send out an alert message. cmd must be a string to spawn a command that accepts
        input on stdin and sends it out to your alert mechanism
    """
    if cmd is not None:
        proc = subprocess.Popen(shlex.split(cmd),
                stdin  = subprocess.PIPE,
                stdout = subprocess.PIPE,
                universal_newlines=True,
                bufsize=0)
        proc.stdin.write(message)
        proc.stdin.close()
        proc.wait()

parser = argparse.ArgumentParser(description = 'Driver for rdiff-backup')
config = ConfigParser()

#
# Get some info about who I am
#
HOME     = path.expanduser('~')
HOSTNAME = socket.gethostname()
USER     = getpass.getuser()
#
# Pre-Load system variables
#
config['DEFAULT']['HOME'] = HOME
config['DEFAULT']['USER'] = USER
config['DEFAULT']['HOSTNAME'] = HOSTNAME
# Default ini files
config_default = ['/etc/rdb3/rdb.ini', HOME+'/.config/rdb3/rdb.ini', 'rdb.ini']
config_file = []
#
# Build parser
#
parser.add_argument('-c', '--config-file',
                    action='append',
                    metavar = 'CONFIG.INI',
                    help='A config file in ini format')
parser.add_argument('-n', '--no-default',
                    action='count',
                    help='Ignore default ini files')
parser.add_argument('--version', action='version',
                    help='Show version number',
                    version='3.1.0')
parser.add_argument('--long-help', action='count',
                    help='Show ini-file help')
#
# Get flags from command line
#
try:
    args = parser.parse_args()
except SystemExit:
    print('Something went wrong, fire logger/xmpp')
    sys.exit(2)
#
if args.long_help:
    #TODO: do_longhelp()
    sys.exit(1)
if args.no_default:
    # print('Not reading default files')
    config_default = []

config_file = config_default
if args.config_file:
    config_file = config_default + args.config_file
#
# Read config
#
cfg = config.read( config_file )
print('cfg is ', cfg)
if cfg==[]:
    print('No ini-file found. Giving up')
    sys.exit(2)
general = config['general']#
# We have our config, now try to configure logging.
#
try:
    logging.config.fileConfig( general.get('logging') )
    # create logger
    logger = logging.getLogger('root')
except:
    # Create a basic logger to stderr, with debug level,
    logging.basicConfig(format='%(asctime)s - %(levelname)s: %(message)s', level=logging.DEBUG)
    # so hopefully someone hears us
    logger = logging.getLogger();
#
# Configure logging
#
#logging.basicConfig(format='%(asctime)s: %(message)s')
#logger = logging.getLogger('rdb3')
#logger.setLevel('WARN')
#
# Rest of general config
#
rdb     = general.get('rdiff-backup', '/usr/bin/rdiff-backup')
server  = general.get('server', '')
user    = general.get('user', USER)
dry_run = general.get('dry_run', 0)
glopts  = general.get('options','')
alert   = general.get('alert', None)
tweetOK = general.get('tweetOK', False)
# Anything better? /var/log/rdb3 ??
logdir  = general.get('logdir', '/tmp')
logf = open(logdir + '/logf', 'w')
logger.debug('Done ini-Files')

#
# test directory / server
#
if server=='':
    # Local repo. Check if it exists
    repo   = general.get('repository')
    if not path.isdir(repo):
        logger.critical('Repository %s seems not to exist', repo)
        tweetAlert(alert, HOSTNAME + ': rdb3 repository ' + repo + ' does not exist')
        raise
    # check if writeable
    if not access(repo, W_OK):
        logger.critical('Writing to %s seems to be forbidden', repo)
        tweetAlert(alert, HOSTNAME + ': rdb3 cannot write to repository '+repo)
        raise
    dst=repo
    SCH=' '
else:
    key = general['key']
    logger.info('SSH-Key: %s', key)
    logger.info('Server: %s', server)
    logger.info('User  : %s', user)
    if user !='' : server = user+ '@' + server
    cmd = 'ssh -i %s %s repo' % (key, server)
    logger.debug('Getting repo with %s', cmd)
    p = subprocess.run(shlex.split(cmd), stdout = subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines = True) # encoding='utf-8')
    if p.returncode == 0:
        repo = p.stdout.strip()
        if not repo.endswith('/'): repo = repo + '/'
        logger.info('Repo  : %s', repo)
        dst = server + '::' + repo
        logger.info('dst   : %s', dst)
        # prepare test
        SCH = ' --remote-schema "ssh -i %s -C %%s test"' % (key)
        cmd = rdb + SCH + ' --test-server ' + dst
        logger.debug('Testing server with %s', cmd)
        p = subprocess.run( shlex.split(cmd),stdout = subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines = True) # encoding='utf-8' )
        if p.returncode !=0:
            logger.critical('Could no start server: %s', p.stderr)
            tweetAlert(alert, HOSTNAME + ': Server does not handle test')
            sys.exit(1)

        SCH = ' --remote-schema "ssh -i %s -C %%s backup"' % (key)
        logger.debug('Using remote scheme %s', SCH)
    else:
        tweetAlert(alert, HOSTNAME + ': cannot contact server')
        logger.critical('Problem contacting server: %s', p.stderr)
        sys.exit(1)
#
# All preps done, now we can start running jobs
#
jobs = general.get('jobs','').split(';')
# Run all jobs
for job in jobs:
    logger.info('Preparing job %s', job)
    try:
        jobc  = config[job]
        local = jobc['local']
    except:
        logger.critical('Job section [%s] does not exist or badly configured',job)
        tweetAlert(alert, HOSTNAME + ': Missing or malformed job configuration')
        raise
    # make remote path
    remote = jobc.get('remote', local).replace('/','_')
    remote = re.sub(r'^_', '', remote)
    #
    lopts  = jobc.get('options', '')
    # Get all OPTxx keys
    i = 0
    while True:
        key = 'OPT%02d' % (i)
        val = jobc.get(key, '')
        if val == '':
            break
        else:
            # add to opts
            lopts += ' ' + val
            i += 1
    #
    # run pre-job
    precmd  = jobc.get('precmd', '')
    if precmd != '':
        logger.info('Running pre command <%s>', precmd)
        args = shlex.split(precmd)
        p=subprocess.run(args,stdout=logf, stderr=subprocess.PIPE, universal_newlines = True) # encoding='utf-8')
        if p.returncode != 0:
            tweetAlert(alert, HOSTNAME + ': Failed pre-command')
            logger.critical('Precommand for job %s failed, stderr=%s', job, p.stderr)
    # run main job
    cmd = rdb + ' ' + SCH + ' ' + glopts + ' ' + lopts + ' '
    cmd += local + ' ' + dst + remote
    logger.info('running <%s>', shlex.split(cmd))
    p = subprocess.run(shlex.split(cmd), stdout=logf, stderr=logf, universal_newlines = True) # encoding='utf-8')
    if p.returncode !=0:
        logger.critical('Backup failed, check logs')
        tweetAlert(alert, HOSTNAME + ': rdb3 failed on job ' + job)
        sys.exit(1)
    # run post-job
    postcmd = jobc.get('postcmd', '')
    if postcmd != '':
        logger.info('Running post command <%s>', postcmd)
        args = shlex.split(postcmd)
        print(args)
        p=subprocess.run(args,stdout=logf, stderr=subprocess.PIPE, universal_newlines = True) # encoding='utf-8')
        if p.returncode != 0:
            tweetAlert(alert, HOSTNAME+': Failed post-command')
            logger.critical('Postcommand failed for job %s, stderr=%s', job, p.stderr)
# Clean up
logger.info('Finished all jobs')
if tweetOK:
    tweetAlert(alert, HOSTNAME +": rdb3 finished OK")
logf.close()
